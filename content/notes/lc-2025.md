+++
title = 'LC 2025'
date = 2025-08-16T09:05:05-04:00
+++

## References

- [LeetCode](https://leetcode.cn/)
- [Bit Manipulation Notes](https://leetcode.cn/discuss/post/3571304/cong-ji-he-lun-dao-wei-yun-suan-chang-ji-enve/)
- [Prefix Sum 2D Notes](https://leetcode.cn/discuss/post/3573466/tu-jie-er-wei-qian-zhui-he-fu-mo-ban-dai-s2ag/)
- [Difference Array Notes](https://leetcode.cn/discuss/post/3573741/suan-fa-xiao-ke-tang-chai-fen-shu-zu-pyt-fyl2/)
- [Modular Arithmetic Notes: modular arithmetic identities/Fermat's Little Theorem/binomial coefficient(n choose k)](https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/)

## Problem List

- [Data Structures: basic/prefix sum/stack/queue/heap/trie/union-find/fenwick tree (BIT (binary indexed tree))/segment tree](https://leetcode.cn/discuss/post/3583665/fen-xiang-gun-ti-dan-chang-yong-shu-ju-j-bvmv/)
- [Sliding Window and Two Pointers: fixed-length sliding window/variable-length sliding window/single-sequence case (on one array/string)/two-sequence case (on two arrays/strings)/three pointers/grouped iteration](https://leetcode.cn/circle/discuss/0viNMK/)
- [DP: knapsack (0/1)/partition/state-machine/interval/bitmask/digit/tree/DP optimization](https://leetcode.cn/discuss/post/3581838/fen-xiang-gun-ti-dan-dong-tai-gui-hua-ru-007o/)
- [Bit Manipulation: basic/XOR/AND/OR/LogTrick](https://leetcode.cn/discuss/post/3580371/fen-xiang-gun-ti-dan-wei-yun-suan-ji-chu-nth4/)
- [Binary Search: binary search on the answer (space)/minimize the maximum (value)/maximize the minimum (value)/k-th smallest (element)](https://leetcode.cn/discuss/post/3581838/fen-xiang-gun-ti-dan-dong-tai-gui-hua-ru-007o/)
- [Monotonic Stack: rectangle(largest rectangle in a histogram; maximal rectangle in a binary matrix)/contribution technique/lexicographically smallest](https://leetcode.cn/discuss/post/3579480/ti-dan-dan-diao-zhan-ju-xing-xi-lie-zi-d-u4hk/)
- [Grid: DFS/BFS](https://leetcode.cn/discuss/post/3580195/fen-xiang-gun-ti-dan-wang-ge-tu-dfsbfszo-l3pa/)
- [Graph Algorithm: DFS/BFS/topological sort/unicyclic graph/shortest path/minimum spanning tree (MST)/network flow](https://leetcode.cn/discuss/post/3581143/fen-xiang-gun-ti-dan-tu-lun-suan-fa-dfsb-qyux/)
- [Mathematical Algorithm: number theory/combinatorics/probability and expectation/game theory/computational geometry/randomized algorithms](https://leetcode.cn/discuss/post/3584388/)
- [Greedy Algorithm: basic/rollback/interval/lexicographic/math-based/greedy thinking/constructive](https://leetcode.cn/discuss/post/3091107/fen-xiang-gun-ti-dan-tan-xin-ji-ben-tan-k58yb/)
- [Linked List, Binary Tree, Backtracking: front-back pointers/fast-slow pointers/DFS/BFS/diameter/LCA/general tree](https://leetcode.cn/discuss/post/3142882/fen-xiang-gun-ti-dan-lian-biao-er-cha-sh-6srp/)
- [String: KMP (Knuth-Morris-Pratt; prefix function/pi array)/Manacher (longest palindromic substring)/string hashing/AC automation(Aho-Corasick automation; trie with failure links)/suffix array (SA; LCP array (longest common prefix))](https://leetcode.cn/discuss/post/3144832/fen-xiang-gun-ti-dan-zi-fu-chuan-kmpzhan-ugt4/)

## Data Structures

### Basic

#### 1. Enumerate the right, maintain the left.

**Core Concept:**
For two-variable problems like the two-sum where `a_i + a_j = t`:

- Enumerate the right-hand variable `a_j`
- Transform into a single-variable problem: find `a_i = t - a_j`
- Use a hash table to maintain previously seen left elements

**Implementation Pattern:**

```python
def two_sum_pattern(arr, target):
    seen = {}  # Hash table for left elements

    for j, a_j in enumerate(arr):
        complement = target - a_j
        if complement in seen:
            return [seen[complement], j]
        seen[a_j] = j

    return None
```

#### 2. Enumerate the middle.

**Core Concept:**
When dealing with multiple variables with ordering constraints, enumerate the middle variable to automatically separate the problem space.

| Strategy               | Best For             | Time  | Space | Key Tool     |
| ---------------------- | -------------------- | ----- | ----- | ------------ |
| **Right Enumeration**  | 2-variable problems  | O(n)  | O(n)  | Hash table   |
| **Middle Enumeration** | 3+ variable problems | O(nÂ²) | O(1)  | Two pointers |

**Implementation Pattern:**

```python
def three_sum_pattern(arr):
    arr.sort()  # Enable two-pointer technique
    result = []

    for j in range(1, len(arr) - 1):  # Enumerate middle
        left, right = 0, len(arr) - 1

        while left < j and right > j:
            current_sum = arr[left] + arr[j] + arr[right]

            if current_sum == target:
                result.append([arr[left], arr[j], arr[right]])
                left += 1
                right -= 1
            elif current_sum < target:
                left += 1
            else:
                right -= 1

    return result
```
